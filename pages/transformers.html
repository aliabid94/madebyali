<!DOCTYPE html>
<html lang="en">

<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WM5YFXBNP2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-WM5YFXBNP2');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformers - madebyali</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link href="/static/styles.css" rel="stylesheet">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">
</head>

<body class="transformers w-full relative min-h-screen flex flex-col">
    <nav class="mx-auto container px-4 flex pt-4 justify-between items-center w-full">
        <a href="/"><img src="/static/logo.png" class="h-5 sm:h-6 dark:invert"></a>
        <div>
            <h1 class="text-md text-center text-xl">transformers</h1>
            <div class="text-xs text-gray-500 dark:text-gray-400">
                <span id="date"></span> puzzle: <span id="timer">--:--</span>
            </div>
        </div>
        <button id="howToPlayBtn" class="outline-none hover:underline text-xs sm:text-base">how to play</button>
    </nav>
    <main class="mx-auto container px-4 flex-1 flex items-center justify-center">
        <div id="gameContainer" class="w-full max-w-md mb-8">
            <!-- Words will be dynamically generated here -->
        </div>
    </main>

    <div id="modal" class="fixed inset-0 bg-black bg-opacity-50 items-center justify-center hidden z-50">
        <div
            class="bg-white dark:bg-gray-900 rounded p-8 min-w-96 max-w-md max-h-full overflow-y-auto mx-4 relative text-sm">
            <button id="closeModal"
                class="absolute top-2 right-2 text-gray-500 hover:text-gray-700 text-5xl">&times;</button>

            <div id="instructionsContent">
                <h2 class="text-lg mb-4">how to play transformers</h2>
                <p class="mb-3">You must create a chain of words that connect the given start and end words. Each word
                    in the chain must be connected to the word before through any of the 4 valid transformations listed
                    below.</p>
                <p>The example connects "CAT" to "EAR" with each of the 4 types of valid transformations.</p>

                <!-- Example chain visualization -->
                <div class="text-center">
                    <div class="my-4 flex-col inline-flex">
                        <!-- CAT -->
                        <div class="flex items-center gap-2">
                            <div class="flex items-center gap-2 flex-1 pl-4">
                                <div class="flex justify-center gap-1">
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase bg-gray-100 dark:bg-gray-700">
                                        C</div>
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase bg-gray-100 dark:bg-gray-700">
                                        A</div>
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase bg-gray-100 dark:bg-gray-700">
                                        T</div>
                                </div>
                                <div class="w-2 h-2 rounded-full bg-green-500"></div>
                            </div>
                        </div>
                        <!-- Transformation circle -->
                        <div class="flex my-1">
                            <div class="flex-1 pl-[54px]">
                                <div class="w-2 h-2 rounded-full bg-green-500"></div>
                            </div>
                        </div>
                        <!-- CART -->
                        <div class="flex items-center gap-2">
                            <div class="flex items-center gap-2">
                                <div class="flex justify-center gap-1">
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase">
                                        C</div>
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase">
                                        A</div>
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase">
                                        R</div>
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase">
                                        T</div>
                                </div>
                                <div class="w-2 h-2 rounded-full bg-green-500"></div>
                            </div>
                            <div class="text-xs text-gray-600 dark:text-gray-400">1. Add a letter <strong>(T)</strong>
                            </div>
                        </div>
                        <!-- Transformation circle -->
                        <div class="flex my-1">
                            <div class="flex-1 pl-[54px]">
                                <div class="w-2 h-2 rounded-full bg-green-500"></div>
                            </div>
                        </div>
                        <!-- ART -->
                        <div class="flex items-center gap-2">
                            <div class="flex items-center gap-2 pl-4">
                                <div class="flex justify-center gap-1">
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase">
                                        A</div>
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase">
                                        R</div>
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase">
                                        T</div>
                                </div>
                                <div class="w-2 h-2 rounded-full bg-green-500"></div>
                            </div>
                            <div class="text-xs text-gray-600 dark:text-gray-400">2. Remove a letter
                                <strong>(C)</strong></div>
                        </div>
                        <!-- Transformation circle -->
                        <div class="flex my-1">
                            <div class="flex-1 pl-[54px]">
                                <div class="w-2 h-2 rounded-full bg-green-500"></div>
                            </div>
                        </div>
                        <!-- ARE -->
                        <div class="flex items-center gap-2">
                            <div class="flex items-center gap-2 pl-4">
                                <div class="flex justify-center gap-1">
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase">
                                        A</div>
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase">
                                        R</div>
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase">
                                        E</div>
                                </div>
                                <div class="w-2 h-2 rounded-full bg-green-500"></div>
                            </div>
                            <div class="text-xs text-gray-600 dark:text-gray-400">3. Swap a letter <strong>(T to
                                    E)</strong></div>
                        </div>
                        <!-- Transformation circle -->
                        <div class="flex my-1">
                            <div class="flex-1 pl-[54px]">
                                <div class="w-2 h-2 rounded-full bg-green-500"></div>
                            </div>
                        </div>
                        <!-- EAR -->
                        <div class="flex items-center gap-2 mb-2">
                            <div class="flex items-center gap-2 pl-4">
                                <div class="flex justify-center gap-1">
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase bg-gray-100 dark:bg-gray-700">
                                        E</div>
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase bg-gray-100 dark:bg-gray-700">
                                        A</div>
                                    <div
                                        class="w-6 h-6 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-sm font-semibold uppercase bg-gray-100 dark:bg-gray-700">
                                        R</div>
                                </div>
                                <div class="w-2 h-2 rounded-full bg-green-500"></div>
                            </div>
                            <div class="text-xs text-gray-600 dark:text-gray-400">4. Rearrange letters</div>
                        </div>
                    </div>
                </div>

                <p class="mb-3">A green circle next to a word means it is a valid dictionary word. A green circle
                    between words means it is a valid transformation. A green circle does not necessarily mean the word
                    is part of the correct chain. You cannot reuse a word in the chain.</p>
            </div>

            <div id="completionContent" class="hidden">
                <p>You completed today's transformers puzzle!</p>
                <p>Time: <span class="font-semibold" id="completionTime"></span></p>
                <p>Streak: <span class="font-semibold" id="completionStreak"></span></p>
                <p>"No Hint" Streak: <span class="font-semibold" id="completionNoHintStreak"></span></p>
                <button id="shareBtn"
                    class="mt-1 mb-6 bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg font-medium w-full">Share</button>
                <div>
                    <p class="mb-3">Another puzzle you may like!</p>
                    <a href="/fishwish" class="link-card block no-underline">
                        <div class="link-card-tag new-daily">New Puzzle Daily</div>
                        <div class="title">fishwish</div>
                        <div class="details">A game where you find rhyming pairs from a set of definitions.</div>
                    </a>
                </div>
            </div>
        </div>
    </div>

    <div
        class="keyboard sticky bottom-0 left-0 right-0 bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 p-4 bg-opacity-50 dark:bg-opacity-50 z-20">
        <div class="absolute bottom-full left-0 flex w-full justify-center">
            <button id="hintButton"
                class="rounded-t border border-b-0 border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-4 py-1 hidden">Get
                Hint</button>
        </div>
        <div class="max-w-xl mx-auto">
            <div class="grid grid-cols-10 gap-1 sm:gap-2 mb-2">
                <button class="key" data-key="q">Q</button>
                <button class="key" data-key="w">W</button>
                <button class="key" data-key="e">E</button>
                <button class="key" data-key="r">R</button>
                <button class="key" data-key="t">T</button>
                <button class="key" data-key="y">Y</button>
                <button class="key" data-key="u">U</button>
                <button class="key" data-key="i">I</button>
                <button class="key" data-key="o">O</button>
                <button class="key" data-key="p">P</button>
            </div>
            <div class="grid grid-cols-9 gap-1 sm:gap-2 mb-2 px-4">
                <button class="key" data-key="a">A</button>
                <button class="key" data-key="s">S</button>
                <button class="key" data-key="d">D</button>
                <button class="key" data-key="f">F</button>
                <button class="key" data-key="g">G</button>
                <button class="key" data-key="h">H</button>
                <button class="key" data-key="j">J</button>
                <button class="key" data-key="k">K</button>
                <button class="key" data-key="l">L</button>
            </div>
            <div class="grid grid-cols-8 gap-1 sm:gap-2 px-8">
                <button class="key" data-key="z">Z</button>
                <button class="key" data-key="x">X</button>
                <button class="key" data-key="c">C</button>
                <button class="key" data-key="v">V</button>
                <button class="key" data-key="b">B</button>
                <button class="key" data-key="n">N</button>
                <button class="key" data-key="m">M</button>
                <button class="key" data-key="backspace">âŒ«</button>
            </div>
        </div>
    </div>

    <script>
        // timer and game state management
        const gamename = "transformers";

        const timerSpan = document.getElementById('timer');
        let startTime = Date.now();
        let elapsedTime = 0;
        let timerInterval;
        let isTimerRunning = false;

        // Get offset from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const offset = parseInt(urlParams.get('offset')) || 0;

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        today.setDate(today.getDate() + offset);
        const todayString = today.toLocaleDateString('en-US');
        const gameKey = `${gamename}-${todayString}`;
        const visitedKey = `${gamename}-visited`;
        const completionsKey = `${gamename}-completions`;

        const firstDay = new Date('2025-10-03');
        firstDay.setHours(0, 0, 0, 0);
        const daysSinceFirstDay = Math.floor((today - firstDay) / (1000 * 60 * 60 * 24));

        let gameState = localStorage.getItem(gameKey);
        if (gameState) {
            gameState = JSON.parse(gameState);
            elapsedTime = gameState.elapsedTime || 0;
            // Initialize new fields for backward compatibility
            if (!gameState.revealedHints) gameState.revealedHints = [];
            if (gameState.hintsUsed === undefined) gameState.hintsUsed = 0;
        } else {
            elapsedTime = 0;
            gameState = {
                elapsedTime: 0,
                complete: false,
                currentWords: [],
                usedHint: false,
                revealedHints: [], // Array of {wordIndex, letterIndex}
                hintsUsed: 0,
            };
        }
        let visitedState = localStorage.getItem(visitedKey);
        if (!visitedState) {
            localStorage.setItem(visitedKey, 'true');
        }
        let completionsState = localStorage.getItem(completionsKey);
        if (completionsState) {
            completionsState = JSON.parse(completionsState);
        } else {
            completionsState = [];
        }
        const noHintCompletionsKey = `${gamename}-no-hint-completions`;
        let noHintCompletionsState = localStorage.getItem(noHintCompletionsKey);
        if (noHintCompletionsState) {
            noHintCompletionsState = JSON.parse(noHintCompletionsState);
        } else {
            noHintCompletionsState = [];
        }

        function setGameState(key, value) {
            gameState[key] = value;
            localStorage.setItem(gameKey, JSON.stringify(gameState));
        }

        // modal management
        const modal = document.getElementById('modal');
        const howToPlayBtn = document.getElementById('howToPlayBtn');
        const closeModalBtn = document.getElementById('closeModal');

        function showModal() {
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            stopTimer();
        }

        function hideModal() {
            modal.classList.remove('flex');
            modal.classList.add('hidden');

            document.getElementById('instructionsContent').classList.remove('hidden');
            document.getElementById('completionContent').classList.add('hidden');

            if (!gameState.complete) startTimer();
        }

        function showCompletionModal() {
            const minutes = Math.floor(gameState.elapsedTime / 60);
            const seconds = gameState.elapsedTime % 60;
            const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            document.getElementById('instructionsContent').classList.add('hidden');
            document.getElementById('completionContent').classList.remove('hidden');

            document.getElementById('completionTime').textContent = timeString;

            if (!completionsState.includes(todayString)) completionsState.push(todayString);
            localStorage.setItem(completionsKey, JSON.stringify(completionsState));

            // Track no-hint completions
            if (!gameState.usedHint && !noHintCompletionsState.includes(todayString)) {
                noHintCompletionsState.push(todayString);
                localStorage.setItem(noHintCompletionsKey, JSON.stringify(noHintCompletionsState));
            }

            let streak = 0;
            let currentDate = new Date();
            for (let i = completionsState.length - 1; i >= 0; i--) {
                const completionDate = new Date(completionsState[i]);
                if ((currentDate - completionDate) / (1000 * 60 * 60 * 24) < 1) {
                    streak++;
                    currentDate.setDate(currentDate.getDate() - 1);
                } else {
                    break;
                }
            }

            // Calculate no-hint streak
            let noHintStreak = 0;
            let noHintCurrentDate = new Date();
            for (let i = noHintCompletionsState.length - 1; i >= 0; i--) {
                const completionDate = new Date(noHintCompletionsState[i]);
                if ((noHintCurrentDate - completionDate) / (1000 * 60 * 60 * 24) < 1) {
                    noHintStreak++;
                    noHintCurrentDate.setDate(noHintCurrentDate.getDate() - 1);
                } else {
                    break;
                }
            }

            document.getElementById('completionStreak').textContent = `${streak} day${streak !== 1 ? 's' : ''}`;
            document.getElementById('completionNoHintStreak').textContent = `${noHintStreak} day${noHintStreak !== 1 ? 's' : ''}`;

            modal.classList.remove('hidden');
            modal.classList.add('flex');

            const modalContent = modal.querySelector('div');
            modalContent.classList.add('modal-pop-in');
        }

        document.getElementById('shareBtn').addEventListener('click', function () {
            const btn = this;
            const originalText = btn.textContent;
            const minutes = Math.floor(gameState.elapsedTime / 60);
            const seconds = gameState.elapsedTime % 60;
            const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            const shareMessage = `Beat my time ${timeString} at transformers: ${window.location.href}`;
            navigator.clipboard.writeText(shareMessage).then(() => {
                btn.textContent = 'Copied to Clipboard!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            });
        });

        if (!visitedState) {
            showModal();
        }

        howToPlayBtn.addEventListener('click', showModal);
        closeModalBtn.addEventListener('click', hideModal);

        modal.addEventListener('click', function (e) {
            if (e.target === modal) {
                hideModal();
            }
        });

        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
                hideModal();
            }
        });

        // date & timer display
        const dateSpan = document.getElementById('date');
        const months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun',
            'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
        const formattedDate = months[today.getMonth()] + ' ' + today.getDate();
        dateSpan.textContent = formattedDate;

        function printTimer() {
            const minutes = Math.floor(gameState.elapsedTime / 60);
            const seconds = gameState.elapsedTime % 60;
            timerSpan.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        printTimer();

        function updateTimer() {
            setGameState('elapsedTime', gameState.elapsedTime + 1);
            printTimer();
        }

        function startTimer() {
            if (!isTimerRunning) {
                timerInterval = setInterval(updateTimer, 1000);
                isTimerRunning = true;
            }
        }

        function stopTimer() {
            if (isTimerRunning) {
                clearInterval(timerInterval);
                isTimerRunning = false;
            }
        }

        if (!gameState.complete && visitedState) {
            startTimer();
        }

        // game mechanics
        let game;
        let selectedLetterIndex = null;
        let currentWords = [];
        let validWords = new Set();

        Promise.all([
            fetch('/static/all-words-8-letter-max.json').then(response => response.json()),
            fetch('/static/transformer-games.json').then(response => response.json())
        ]).then(([validWordsData, gamesData]) => {
            validWords = new Set(validWordsData.map(word => word.toLowerCase()));
            game = gamesData[daysSinceFirstDay % gamesData.length];
            initializeGame();
        });

        function initializeGame() {
            if (gameState.currentWords && gameState.currentWords.length > 0) {
                currentWords = gameState.currentWords;
            } else {
                currentWords = game.map((word, i) => {
                    if (i === 0 || i === game.length - 1) {
                        return word.split('');
                    } else {
                        return Array(word.length).fill('');
                    }
                });
                setGameState('currentWords', currentWords);
            }

            renderGame();

            if (!gameState.complete) {
                selectNextEmptyLetter();
            }
        }

        function renderGame() {
            const container = document.getElementById('gameContainer');
            container.innerHTML = '';

            for (let i = 0; i < currentWords.length; i++) {
                const wordContainer = document.createElement('div');
                wordContainer.className = 'flex justify-center items-center gap-2 mb-2';

                const wordDiv = document.createElement('div');
                wordDiv.className = 'flex justify-center gap-1';

                for (let j = 0; j < currentWords[i].length; j++) {
                    const letterBox = document.createElement('div');
                    letterBox.className = 'w-10 h-10 border-2 border-gray-300 dark:border-gray-500 rounded flex items-center justify-center text-lg font-semibold uppercase';

                    const isFirstOrLast = i === 0 || i === currentWords.length - 1;
                    // Check if this letter is a revealed hint
                    const isRevealedHint = gameState.revealedHints && gameState.revealedHints.some(
                        hint => hint.wordIndex === i && hint.letterIndex === j
                    );

                    if (isFirstOrLast || isRevealedHint) {
                        letterBox.classList.add('bg-gray-100', 'dark:bg-gray-700');
                    } else {
                        letterBox.classList.add('cursor-pointer', 'hover:bg-gray-50', 'dark:hover:bg-gray-800');
                        letterBox.dataset.wordIndex = i;
                        letterBox.dataset.letterIndex = j;
                        letterBox.addEventListener('click', handleLetterClick);
                    }

                    // Always add data attributes for the flash animation to find the element
                    if (!isFirstOrLast) {
                        letterBox.dataset.wordIndex = i;
                        letterBox.dataset.letterIndex = j;
                    }

                    letterBox.textContent = currentWords[i][j];

                    if (selectedLetterIndex && selectedLetterIndex.word === i && selectedLetterIndex.letter === j) {
                        letterBox.classList.add('border-pink-500', 'dark:border-pink-400');
                    }

                    wordDiv.appendChild(letterBox);
                }

                wordContainer.appendChild(wordDiv);

                const wordValidationCircle = document.createElement('div');
                wordValidationCircle.className = 'w-4 h-4 rounded-full';

                const wordValidationState = validateWord(currentWords[i]);
                if (wordValidationState === 'valid') {
                    wordValidationCircle.classList.add('bg-green-500');
                } else if (wordValidationState === 'invalid') {
                    wordValidationCircle.classList.add('bg-red-500');
                } else {
                    wordValidationCircle.classList.add('bg-gray-300', 'dark:bg-gray-600');
                }

                wordContainer.appendChild(wordValidationCircle);
                container.appendChild(wordContainer);

                if (i < currentWords.length - 1) {
                    const circleDiv = document.createElement('div');
                    circleDiv.className = 'flex justify-center my-1';

                    const circle = document.createElement('div');
                    circle.className = 'w-4 h-4 rounded-full';

                    const validationState = validateTransformation(currentWords[i], currentWords[i + 1]);
                    if (validationState === 'valid') {
                        circle.classList.add('bg-green-500');
                    } else if (validationState === 'invalid') {
                        circle.classList.add('bg-red-500');
                    } else {
                        circle.classList.add('bg-gray-300', 'dark:bg-gray-600');
                    }

                    circleDiv.appendChild(circle);
                    container.appendChild(circleDiv);
                }
            }

            checkWinCondition();
            updateHintButtonVisibility();
        }

        function updateHintButtonVisibility() {
            const hintButton = document.getElementById('hintButton');

            if (gameState.complete) {
                hintButton.classList.add('hidden');
                return;
            }

            // Calculate number of intermediate words
            const numIntermediateWords = game ? game.length - 2 : 0;

            // Show hint button if hints are still available
            if (gameState.hintsUsed < numIntermediateWords) {
                hintButton.classList.remove('hidden');
            } else {
                hintButton.classList.add('hidden');
            }
        }


        function validateWord(word) {
            if (word.includes('')) {
                return 'incomplete';
            }

            const wordStr = word.join('').toLowerCase();

            // Check if word is valid in dictionary
            if (!validWords.has(wordStr)) {
                return 'invalid';
            }

            // Check if word is used more than once
            let occurrences = 0;
            for (let i = 0; i < currentWords.length; i++) {
                if (!currentWords[i].includes('') && currentWords[i].join('').toLowerCase() === wordStr) {
                    occurrences++;
                }
            }

            if (occurrences > 1) {
                return 'invalid';
            }

            return 'valid';
        }

        function validateTransformation(word1, word2) {
            if (word1.includes('') || word2.includes('')) {
                return 'incomplete';
            }

            const w1 = word1.join('').toLowerCase();
            const w2 = word2.join('').toLowerCase();

            if (w1 === w2) {
                return 'invalid';
            }

            // Check for rearrangement (anagram)
            if (w1.split('').sort().join('') === w2.split('').sort().join('')) {
                return 'valid';
            }

            // Check for insertion (w2 has one more letter)
            if (w2.length === w1.length + 1) {
                for (let i = 0; i < w2.length; i++) {
                    const testWord = w2.slice(0, i) + w2.slice(i + 1);
                    if (testWord === w1) {
                        return 'valid';
                    }
                }
            }

            // Check for deletion (w1 has one more letter)
            if (w1.length === w2.length + 1) {
                for (let i = 0; i < w1.length; i++) {
                    const testWord = w1.slice(0, i) + w1.slice(i + 1);
                    if (testWord === w2) {
                        return 'valid';
                    }
                }
            }

            // Check for swap (same length, one letter different)
            if (w1.length === w2.length) {
                let differences = 0;
                for (let i = 0; i < w1.length; i++) {
                    if (w1[i] !== w2[i]) {
                        differences++;
                    }
                }
                if (differences === 1) {
                    return 'valid';
                }
            }

            return 'invalid';
        }

        function handleLetterClick(e) {
            const wordIndex = parseInt(e.target.dataset.wordIndex);
            const letterIndex = parseInt(e.target.dataset.letterIndex);

            // Don't allow clicking on revealed hint letters
            const isRevealedHint = gameState.revealedHints && gameState.revealedHints.some(
                hint => hint.wordIndex === wordIndex && hint.letterIndex === letterIndex
            );

            if (isRevealedHint) return;

            selectedLetterIndex = { word: wordIndex, letter: letterIndex };
            renderGame();
        }

        function selectNextEmptyLetter() {
            // Find first empty letter that's not in first or last word
            for (let i = 1; i < currentWords.length - 1; i++) {
                for (let j = 0; j < currentWords[i].length; j++) {
                    if (currentWords[i][j] === '') {
                        selectedLetterIndex = { word: i, letter: j };
                        renderGame();
                        return;
                    }
                }
            }

            // If no empty letters, select first editable letter
            if (currentWords.length > 2) {
                selectedLetterIndex = { word: 1, letter: 0 };
                renderGame();
            }
        }

        function handleKeyPress(key) {
            if (!selectedLetterIndex || gameState.complete) return;

            const { word, letter } = selectedLetterIndex;

            // Check if this letter is a revealed hint - if so, don't allow editing
            const isRevealedHint = gameState.revealedHints && gameState.revealedHints.some(
                hint => hint.wordIndex === word && hint.letterIndex === letter
            );

            if (isRevealedHint) {
                // Move to next non-hint letter instead
                if (key === 'backspace') {
                    moveSelection('left');
                } else if (/^[a-z]$/.test(key)) {
                    moveSelection('right');
                }
                return;
            }

            if (key === 'backspace') {
                currentWords[word][letter] = '';
                setGameState('currentWords', currentWords);

                // Move cursor backward
                moveSelection('left');
                return;
            } else if (/^[a-z]$/.test(key)) {
                currentWords[word][letter] = key;
                setGameState('currentWords', currentWords);

                // Move to next letter
                let nextWord = word;
                let nextLetter = letter + 1;

                if (nextLetter >= currentWords[word].length) {
                    nextWord++;
                    nextLetter = 0;
                }

                // Skip first and last words
                if (nextWord >= currentWords.length - 1) {
                    nextWord = 1;
                    nextLetter = 0;
                }

                selectedLetterIndex = { word: nextWord, letter: nextLetter };
                renderGame();
            }
        }

        function moveSelection(direction) {
            if (!selectedLetterIndex) return;

            let { word, letter } = selectedLetterIndex;

            if (direction === 'left') {
                letter--;
                if (letter < 0) {
                    word--;
                    if (word < 1) word = currentWords.length - 2;
                    letter = currentWords[word].length - 1;
                }
            } else if (direction === 'right') {
                letter++;
                if (letter >= currentWords[word].length) {
                    word++;
                    if (word >= currentWords.length - 1) word = 1;
                    letter = 0;
                }
            } else if (direction === 'up') {
                word--;
                if (word < 1) word = currentWords.length - 2;
                if (letter >= currentWords[word].length) letter = currentWords[word].length - 1;
            } else if (direction === 'down') {
                word++;
                if (word >= currentWords.length - 1) word = 1;
                if (letter >= currentWords[word].length) letter = currentWords[word].length - 1;
            }

            selectedLetterIndex = { word, letter };
            renderGame();
        }

        function checkWinCondition() {
            // Check if all circles are green (all words and transformations valid)
            let allValid = true;

            // Check all words are valid
            for (let i = 0; i < currentWords.length; i++) {
                if (validateWord(currentWords[i]) !== 'valid') {
                    allValid = false;
                    break;
                }
            }

            // Check all transformations are valid
            if (allValid) {
                for (let i = 0; i < currentWords.length - 1; i++) {
                    if (validateTransformation(currentWords[i], currentWords[i + 1]) !== 'valid') {
                        allValid = false;
                        break;
                    }
                }
            }

            if (allValid && !gameState.complete) {
                setGameState('complete', true);
                handleGameCompletion();
            }
        }

        function handleGameCompletion(animate = true) {
            stopTimer();

            if (animate) {
                const gameContainer = document.getElementById('gameContainer');
                gameContainer.classList.add('win-flash');

                setTimeout(() => {
                    document.querySelector(".keyboard").classList.add('hidden');
                    showCompletionModal();
                }, 500);
            } else {
                document.querySelector(".keyboard").classList.add('hidden');
                showCompletionModal();
            }
        }

        if (gameState.complete) {
            handleGameCompletion(false);
        }

        // Keyboard event listeners
        document.addEventListener('click', function (e) {
            if (e.target.classList.contains('key')) {
                const key = e.target.getAttribute('data-key');
                handleKeyPress(key);
            }
        });

        document.addEventListener('keydown', function (e) {
            if (e.ctrlKey || e.altKey || e.metaKey) return;
            if (e.key === 'Escape' || modal.classList.contains('flex')) return;

            if (e.key === 'Backspace') {
                e.preventDefault();
                handleKeyPress('backspace');
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                moveSelection('left');
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                moveSelection('right');
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                moveSelection('up');
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                moveSelection('down');
            } else if (e.key.length === 1 && /[a-zA-Z]/.test(e.key)) {
                e.preventDefault();
                handleKeyPress(e.key.toLowerCase());
            }
        });

        // Helper function to get hint word order (center-outward alternation)
        function getHintWordOrder(numIntermediateWords) {
            const order = [];
            const middleIndex = 1 + Math.floor((numIntermediateWords - 1) / 2);

            order.push(middleIndex);

            let left = middleIndex - 1;
            let right = middleIndex + 1;
            const maxIndex = numIntermediateWords;

            while (left >= 1 || right <= maxIndex) {
                if (left >= 1) {
                    order.push(left);
                    left--;
                }
                if (right <= maxIndex) {
                    order.push(right);
                    right++;
                }
            }

            return order;
        }

        // Helper function to find which letter to reveal in a word
        function getHintLetterIndex(wordIndex) {
            const currentWord = game[wordIndex].toLowerCase();
            const previousWord = game[wordIndex - 1].toLowerCase();

            // Find first letter that differs from previous word at same position
            for (let i = 0; i < currentWord.length; i++) {
                if (i >= previousWord.length || currentWord[i] !== previousWord[i]) {
                    return i;
                }
            }

            // If no difference found, return middle letter
            return Math.floor(currentWord.length / 2);
        }

        // Reveal a hint letter
        function revealHintLetter() {
            const numIntermediateWords = game.length - 2;

            // Check if all hints have been used
            if (gameState.hintsUsed >= numIntermediateWords) {
                return;
            }

            // Get the order of words to reveal hints
            const hintOrder = getHintWordOrder(numIntermediateWords);
            const wordIndex = hintOrder[gameState.hintsUsed];
            const letterIndex = getHintLetterIndex(wordIndex);

            // Store the revealed hint
            gameState.revealedHints.push({ wordIndex, letterIndex });
            gameState.hintsUsed++;
            setGameState('revealedHints', gameState.revealedHints);
            setGameState('hintsUsed', gameState.hintsUsed);

            // Set the letter in currentWords
            const correctLetter = game[wordIndex][letterIndex].toLowerCase();
            currentWords[wordIndex][letterIndex] = correctLetter;
            setGameState('currentWords', currentWords);

            // Re-render the game
            renderGame();

            // Apply flash animation to the revealed letter
            const letterBoxes = document.querySelectorAll(`[data-word-index="${wordIndex}"][data-letter-index="${letterIndex}"]`);
            if (letterBoxes.length > 0) {
                letterBoxes[0].classList.add('win-flash');
                // Remove animation class after animation completes
                setTimeout(() => {
                    letterBoxes[0].classList.remove('win-flash');
                }, 500);
            }
        }

        // Hint button event listener
        document.getElementById('hintButton').addEventListener('click', function () {
            if (gameState.complete) return;

            // Mark that hint was used
            setGameState('usedHint', true);

            // Reveal a hint letter
            revealHintLetter();
        });
    </script>
</body>

</html>